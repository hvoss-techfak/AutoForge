# AutoForge Configuration File
# All parameters are set to their default values
# You can override any of these by uncommenting and changing the value

# ====================
# Required Parameters
# ====================
# Note: You must specify these when running AutoForge

# Path to the input image file to convert into a 3D layered model
# This is the picture you want to turn into a printable 3D object
# input_image = path/to/your/image.jpg

# Path to CSV file containing material data (brand, name, color hex code, TD/transmissivity values)
# Export this from Hueforge's Filaments menu - it tells AutoForge what colors you have available
# csv_file = path/to/materials.csv
# OR
# Path to JSON file containing material data (alternative to CSV, e.g., Hueforge personal_library.json)
# Use your Hueforge library directly (found in %APPDATA%\HueForge\Filaments\personal_library.json)
# json_file = path/to/materials.json

# ====================
# Input/Output Settings
# ====================

# Folder where all output files will be saved (STL, PNG, swap instructions, project file)
# Creates a directory with your final 3D model, preview image, and printing instructions
output_folder = output

# ====================
# Optimization Settings
# ====================

# Total number of optimization iterations to run (higher = better quality but slower)
# Think of this as how many times the AI tries to improve the model
# More iterations = better results but takes longer to finish
iterations = 6000

# Learning rate for the optimizer (controls step size during optimization)
# How aggressively the AI adjusts colors and layers each iteration
# Too high = unstable/jumpy results, too low = slow improvement and may get stuck
learning_rate = 0.015

# Fraction of iterations to keep tau at initial value before annealing (1.0 = no early annealing)
# Controls when the AI starts making "harder" decisions about which colors to use
# 1.0 means it stays flexible the whole time; lower values make it commit to choices earlier
# Higher = explores more options longer, lower = settles on a solution faster
warmup_fraction = 1.0

# Fraction of iterations where learning rate gradually increases from 0 to target value
# "Eases in" the optimization - starts with tiny adjustments then ramps up
# Prevents wild initial changes that could mess up the starting point
# 0.01 = spends first 1% of iterations slowly increasing the learning rate to avoid early instability
learning_rate_warmup_fraction = 0.01

# Number of iterations without improvement before stopping optimization early
# If the result doesn't get better for this many steps, it stops trying
# Saves time when the AI has found the best solution it can
# 2000 = gives up if no improvement after 2000 consecutive iterations
early_stopping = 2000

# ====================
# Gumbel-Softmax Parameters
# ====================

# Initial temperature for Gumbel-Softmax (higher = more exploration, softer decisions)
# How "fuzzy" the AI's color choices are at the start
# High = considers many color options, low = picks specific colors quickly
# Start high to explore all possibilities
init_tau = 1.0

# Final temperature for Gumbel-Softmax (lower = more discrete, harder decisions)
# How "decisive" the AI becomes by the end
# Low = makes clear, distinct color choices (what you want for the final model)
# The AI gradually transitions from init_tau to final_tau during optimization
final_tau = 0.01

# ====================
# Layer Settings
# ====================

# Height of each printed layer in millimeters (must match your printer's layer height)
# The thickness of each layer your 3D printer lays down
# Common values: 0.04mm (high detail), 0.08mm (balanced), 0.16mm (fast)
# MUST match your actual printer settings or the model won't print correctly
layer_height = 0.04

# Maximum number of layers allowed in the model (approximately 3mm + background height)
# Controls the tallest the printed image can be (max_layers × layer_height = max height)
# 75 layers × 0.04mm = 3mm tall (plus background)
# More layers = taller model with more depth variation
max_layers = 75

# Minimum number of layers after pruning (used to constrain height reduction)
# Prevents pruning from making the model too flat
# 0 = allows completely flat areas, higher values = maintains minimum depth
min_layers = 0

# Height of the solid background base in millimeters (must be divisible by layer_height)
# The opaque base layer that everything sits on (like a canvas)
# 0.24mm = 6 layers at 0.04mm thickness
# IMPORTANT: Must be divisible by layer_height (0.24 / 0.04 = 6 ✓)
background_height = 0.24

# Background color in hexadecimal format (should be a solid/opaque color with TD ≤ 4)
# The color of the base that shows through the translucent layers
# Black (#000000) is common, but you can use white, colors, etc.
# MUST be opaque (low transmissivity/TD) or light will shine through from below
background_color = #000000

# ====================
# Output/STL Settings
# ====================

# Size of the longest dimension of the output STL file in millimeters
# How big the final printed object will be (width or height, whichever is longer)
# 150mm = about 6 inches; adjust based on your printer's bed size
# Larger = more impressive but takes longer to print
stl_output_size = 150

# Factor to reduce processing resolution vs output size (2 = half resolution for faster processing)
# Optimization uses lower resolution to speed up calculations, then scales up for final STL
# 2 = processes at 75mm internally, outputs at 150mm (4x fewer pixels = much faster)
# Higher = faster processing but slightly less detail; 1 = full resolution (slow but max detail)
processing_reduction_factor = 2

# Diameter of the 3D printer nozzle in mm (details smaller than half this will be ignored)
# Your printer can't create features smaller than the nozzle width
# 0.4mm is standard; AutoForge ignores tiny details below 0.2mm (half of this)
# Prevents trying to print impossibly fine details that would fail
nozzle_diameter = 0.4

# ====================
# Pruning Settings
# ====================

# Whether to perform pruning after optimization to reduce colors and swaps
# Simplifies the model by removing unnecessary colors and filament changes
# True = cleaner, more practical prints; False = potentially more colors but harder to print
# Almost always want this enabled unless you have unlimited filaments and patience
perform_pruning = True

# Use fast incremental search method for pruning (faster but may be slightly less optimal)
# Speeds up pruning by checking layers in chunks instead of one-by-one
# True = much faster (recommended); False = exhaustive search (very slow)
fast_pruning = True

# Percentage of layers to process at once during fast pruning (0.05-0.5 typical)
# How many layers to check together when finding things to simplify
# 0.5 = checks 50% of layers at once (fast); 0.05 = checks 5% at once (slower but more thorough)
# Higher = faster pruning, lower = potentially better pruning quality
fast_pruning_percent = 0.5

# Maximum number of unique colors allowed after pruning (reduces material complexity)
# Limits how many different filaments you'll need to print this
# 8 = practical for home printing; 100 = essentially unlimited
# Lower = simpler/cheaper prints, higher = more color accuracy
# 
# IMPORTANT - How this works in different modes:
# • Traditional mode: pruning_max_colors = colored filaments + background
#   Example: pruning_max_colors=4 → 3 colored + 1 background = 4 total filaments
#   Example: pruning_max_colors=8 → 7 colored + 1 background = 8 total filaments
# 
# • FlatForge mode: pruning_max_colors = colored filaments + clear + background
#   Example: pruning_max_colors=4 → 2 colored + 1 clear + 1 background = 4 total filaments
#   Example: pruning_max_colors=8 → 6 colored + 1 clear + 1 background = 8 total filaments
#
# Minimum values:
#   Traditional mode: 2 (1 colored + 1 background)
#   FlatForge mode: 3 (1 colored + 1 clear + 1 background)
pruning_max_colors = 100

# Maximum number of filament swaps allowed after pruning (reduces print time/complexity)
# Each swap = pausing the print to change filament (adds time and failure risk)
# 20 = manageable; 100 = a lot of babysitting required
# Lower = faster/easier prints, higher = more color transitions
pruning_max_swaps = 100

# Maximum number of layers allowed after height pruning
# Can reduce the model's total height to simplify it
# Same as max_layers by default (no height reduction)
# Lower = flatter model with less variation
pruning_max_layer = 75

# ====================
# Visualization Settings
# ====================

# Enable live visualization of the composite image during optimization
# Shows a preview window updating in real-time as the AI works
# True = watch the progress (cool but uses resources); False = just wait for final result
# Disable if running on a server or in the background
visualize = True

# Disable matplotlib render window for Gradio/web interface (0 = enabled, 1 = disabled)
# Turns off pop-up windows when running through a web interface
# 0 = show visualization windows (normal desktop use)
# 1 = no pop-ups (for Gradio, Docker, or headless servers)
disable_visualization_for_gradio = 0

# ====================
# Initialization Settings
# ====================

# Number of different initial height maps to try (best one is selected to start optimization)
# Creates multiple starting points and picks the best one before optimizing
# Like trying 8 different sketches and continuing with the best one
# More = better chance of finding a good solution, but takes longer to start
# 8 = good balance between quality and speed
num_init_rounds = 8

# Number of layers to cluster the image into for initialization (-1 = auto: max_layers/2)
# Groups similar image areas into layers when creating the starting point
# -1 = automatic (uses half of max_layers, e.g., 37 if max_layers=75)
# Higher = more detail in initial guess, lower = simpler starting point
num_init_cluster_layers = -1

# ====================
# Other Settings
# ====================

# Random seed for reproducibility (0 = auto-generate from current time)
# Controls randomness - same seed = identical results every time
# 0 = different result each run (random); any number = reproducible results
# Use a specific number if you want to recreate exact results
random_seed = 0

# Run optimization multiple times and output the best result (1 = single run)
# Repeats the entire process and keeps the best outcome
# 1 = single attempt; 3 = try 3 times and pick the winner
# Higher = better chance of great results but takes N times longer
# Useful when you want the absolute best possible result
best_of = 1

# Check for new discrete results every N iterations (for visualization updates)
# How often to update the preview during optimization
# 100 = refreshes the visualization every 100 iterations
# Lower = more frequent updates (smoother but slower), higher = less frequent (faster)
discrete_check = 100

# ====================
# FlatForge Settings
# ====================

# Enable FlatForge mode to generate separate STL files for each color
# FlatForge creates flat prints where each color is its own STL file
# This allows printing face-down on the build plate for smooth, resin-like finishes
# Requires a multi-material printer (AMS, MMU, or tool changer)
# False = traditional layered HueForge mode; True = FlatForge mode
flatforge = False

# Number of complete transparent/clear layers to add on top in FlatForge mode
# Creates a glossy cap layer over the colored layers for a resin-filled appearance
# 0 = no cap layer; 1+ = adds that many full layers of clear filament on top
# Only used when flatforge = True
cap_layers = 0

# ====================
# Optional Settings
# ====================

# Use Apple Metal Performance Shaders backend on Mac (requires MPS-enabled PyTorch)
# Enables GPU acceleration on Apple Silicon Macs (M1/M2/M3)
# Only works if you have PyTorch with MPS support installed
# Can significantly speed up processing on newer Macs
# mps = False

# Enable TensorBoard logging for monitoring optimization progress
# Creates detailed logs you can view in TensorBoard to see graphs of how optimization progressed
# Useful for debugging or understanding what the AI is doing
# Creates extra files but helps track performance over time
# tensorboard = False

# Name for this run when using TensorBoard logging
# Labels this optimization session in TensorBoard logs
# Helps organize experiments when trying different settings
# Example: "cat_image_high_detail" or "test_run_1"
# run_name = 
